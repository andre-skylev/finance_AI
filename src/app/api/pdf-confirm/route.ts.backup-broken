import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

/**
 * Extrai apenas as informa√ß√µes essenciais do recibo
 * Foco: nome do estabelecimento, data, total (sem salvar imagens)
 */
function extractReceiptEssentials(transactions: any[], receipts: any[]) {
  // Priorizar dados dos receipts se dispon√≠veis
  if (Array.isArray(receipts) && receipts.length > 0) {
    const receipt = receipts[0]
    return {
      merchantName: receipt.merchant || receipt.merchantName || 'Estabelecimento',
      date: receipt.date || receipt.receipt_date || new Date().toISOString().split('T')[0],
      subtotal: typeof receipt.subtotal === 'number' ? receipt.subtotal : null,
      tax: typeof receipt.tax === 'number' ? receipt.tax : null,
      total: typeof receipt.total === 'number' ? receipt.total : calculateTotalFromTransactions(transactions),
      currency: receipt.currency || 'EUR',
      items: receipt.items || [],
      itemCount: receipt.items ? receipt.items.length : (transactions ? transactions.length : 0),
      shouldCreateTransaction: true
    }
  }

  // Fallback: extrair de transa√ß√µes
  if (Array.isArray(transactions) && transactions.length > 0) {
    const total = calculateTotalFromTransactions(transactions)
    const firstTransaction = transactions[0]
    
    return {
      merchantName: extractMerchantFromTransactions(transactions),
      date: firstTransaction.date || firstTransaction.transaction_date || new Date().toISOString().split('T')[0],
      subtotal: null,
      tax: null,
      total: total,
      currency: firstTransaction.currency || 'EUR',
      items: transactions.map((tx, index) => ({
        line_no: index + 1,
        description: tx.description || 'Item',
        total: Math.abs(parseFloat(tx.amount))
      })),
      itemCount: transactions.length,
      shouldCreateTransaction: false // J√° temos as transa√ß√µes individuais
    }
  }

  // Fallback: dados m√≠nimos
  return {
    merchantName: 'Estabelecimento',
    date: new Date().toISOString().split('T')[0],
    subtotal: null,
    tax: null,
    total: 0,
    currency: 'EUR',
    items: [],
    itemCount: 0,
    shouldCreateTransaction: false
  }
}

function calculateTotalFromTransactions(transactions: any[]): number {
  if (!Array.isArray(transactions)) return 0
  return transactions.reduce((sum, tx) => {
    const amount = parseFloat(tx.amount) || 0
    return sum + Math.abs(amount)
  }, 0)
}

function extractMerchantFromTransactions(transactions: any[]): string {
  if (!Array.isArray(transactions) || transactions.length === 0) return 'Estabelecimento'
  
  // Tentar extrair nome do estabelecimento da primeira transa√ß√£o
  const firstDesc = transactions[0].description || ''
  
  // L√≥gica simples para extrair nome do estabelecimento
  const words = firstDesc.split(/\s+/).filter((word: string) => word.length > 2)
  if (words.length > 0) {
    return words.slice(0, 3).join(' ') // Primeiras 3 palavras
  }
  
  return 'Estabelecimento'
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    
    // Verificar autentica√ß√£o
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'N√£o autorizado' }, { status: 401 })
    }

  const { transactions, target, receipts } = await request.json()

  console.log('PDF Confirm - Dados recebidos:', { 
    transactionsCount: transactions?.length, 
    target, 
    receiptsCount: receipts?.length,
    userId: user.id
  })
  console.log('PDF Confirm - Transa√ß√µes:', JSON.stringify(transactions, null, 2))

  if ((!transactions || !Array.isArray(transactions)) && !(target && String(target).startsWith('rec'))) {
      return NextResponse.json({ error: 'Dados inv√°lidos' }, { status: 400 })
    }
    // Roteamento por destino: conta banc√°ria (acc:ID) ou cart√£o de cr√©dito (cc:ID)
    if (typeof target === 'string' && target.startsWith('acc:')) {
      const accountId = target.slice(4)
      // Verificar se a conta pertence ao usu√°rio
      const { data: account, error: accountError } = await supabase
        .from('accounts')
        .select('id, name, currency')
        .eq('id', accountId)
        .eq('user_id', user.id)
        .single()

      if (accountError || !account) {
        return NextResponse.json({ error: 'Conta n√£o encontrada' }, { status: 404 })
      }

      // Buscar categorias para mapear
      const { data: categories } = await supabase
        .from('categories')
        .select('id, name')

      console.log('PDF Confirm - Categorias encontradas:', categories?.length)
      const categoryMap = new Map(categories?.map(cat => [cat.name.toLowerCase(), cat.id]) || [])
      console.log('PDF Confirm - Mapa de categorias:', Array.from(categoryMap.entries()))

      // Preparar transa√ß√µes para inser√ß√£o
      const transactionsToInsert = transactions.map((transaction: any) => {
        // Mapear categoria sugerida para ID
        let categoryId = null
        if (transaction.suggestedCategory) {
          const suggestedLower = String(transaction.suggestedCategory).toLowerCase()
          console.log('PDF Confirm - Procurando categoria:', suggestedLower)
          
          // Busca exata primeiro
          if (categoryMap.has(suggestedLower)) {
            categoryId = categoryMap.get(suggestedLower)
            console.log('PDF Confirm - Categoria encontrada (exata):', categoryId)
          } else {
            // Busca parcial
            for (const [catName, catId] of categoryMap.entries()) {
              if (catName.includes(suggestedLower) || suggestedLower.includes(catName)) {
                categoryId = catId
                console.log('PDF Confirm - Categoria encontrada (parcial):', catName, '->', categoryId)
                break
              }
            }
          }
          
          if (!categoryId) {
            console.log('PDF Confirm - Categoria n√£o encontrada para:', suggestedLower)
          }
        }

        const amt = parseFloat(transaction.amount)
        return {
          user_id: user.id,
          account_id: accountId,
          amount: amt,
          description: transaction.description,
          category_id: categoryId,
          transaction_date: transaction.date,
          currency: account?.currency || 'EUR',
          type: amt >= 0 ? 'income' : 'expense',
          created_at: new Date().toISOString(),
        }
      })

      console.log('PDF Confirm - Transa√ß√µes preparadas para inser√ß√£o:', JSON.stringify(transactionsToInsert, null, 2))

      const { data: insertedTransactions, error: insertError } = await supabase
        .from('transactions')
        .insert(transactionsToInsert)
        .select()

      console.log('PDF Confirm - Resultado da inser√ß√£o:', { insertedTransactions, insertError })

      if (insertError) {
        console.error('Erro ao inserir transa√ß√µes:', insertError)
        return NextResponse.json({ error: 'Erro ao salvar transa√ß√µes' }, { status: 500 })
      }

      // Salvar recibos vinculados √† conta (opcional)
      let receiptsSaved = 0
      if (Array.isArray(receipts) && receipts.length > 0) {
        for (const r of receipts) {
          try {
            // Associar por total e data
            let matchedTxId: string | null = null
            if (Array.isArray(insertedTransactions) && typeof r.total === 'number') {
              const sameDay = (a?: string, b?: string) => {
                if (!a || !b) return false
                const da = new Date(a).toISOString().slice(0,10)
                const db = new Date(b).toISOString().slice(0,10)
                return da === db
              }
              const found = insertedTransactions.find((tx: any) => {
                const amtEqual = Number(tx.amount) === Number(r.total)
                const dateEqual = sameDay(tx.date || tx.transaction_date, r.date)
                return amtEqual && dateEqual
              })
              matchedTxId = found?.id || null
            }

            const { data: receiptRow, error: recErr } = await supabase
              .from('receipts')
              .insert({
                user_id: user.id,
                account_id: accountId,
                transaction_id: matchedTxId,
                merchant_name: r.merchant || null,
                receipt_date: r.date || null,
                subtotal: typeof r.subtotal === 'number' ? r.subtotal : null,
                tax: typeof r.tax === 'number' ? r.tax : null,
                total: typeof r.total === 'number' ? r.total : null,
              })
              .select('id')
              .single()

            if (!recErr && receiptRow?.id && Array.isArray(r.items)) {
              const itemsToInsert = r.items.map((it: any, index: number) => ({
                user_id: user.id,
                receipt_id: receiptRow.id,
                line_no: index + 1,
                description: String(it.description || 'Item'),
                quantity: typeof it.quantity === 'number' ? it.quantity : null,
                unit_price: typeof it.unitPrice === 'number' ? it.unitPrice : null,
                tax_rate: typeof it.taxRate === 'number' ? it.taxRate : null,
                tax_amount: typeof it.taxAmount === 'number' ? it.taxAmount : null,
                total: typeof it.total === 'number' ? it.total : null,
                sku: it.code ? String(it.code) : null,
              }))
              const { error: itemsErr } = await supabase
                .from('receipt_items')
                .insert(itemsToInsert)
              if (itemsErr) console.error('Erro ao inserir itens do recibo:', itemsErr)
            }
            receiptsSaved++
          } catch (e) {
            console.error('Falha ao salvar recibo:', e)
          }
        }
      }

      return NextResponse.json({
        success: true,
        message: `${(insertedTransactions as any[]).length} transa√ß√µes adicionadas com sucesso${receiptsSaved ? `, ${receiptsSaved} recibo(s) salvo(s)` : ''}`,
        transactions: insertedTransactions,
        receiptsSaved
      })
    }

    if (typeof target === 'string' && target.startsWith('cc:')) {
      const creditCardId = target.slice(3)
      // Verificar se o cart√£o pertence ao usu√°rio
      const { data: card, error: cardErr } = await supabase
        .from('credit_cards')
        .select('id, currency, current_balance')
        .eq('id', creditCardId)
        .eq('user_id', user.id)
        .single()
      if (cardErr || !card) {
        return NextResponse.json({ error: 'Cart√£o n√£o encontrado' }, { status: 404 })
      }

      // Preparar transa√ß√µes de cart√£o (uso positivo; distinguir compra/pagamento pelo sinal)
      const toInsert = transactions.map((tx: any) => {
        const amtNum = Number(tx.amount)
        const isPurchase = amtNum >= 0
        return {
          user_id: user.id,
          credit_card_id: creditCardId,
          transaction_date: tx.date,
          merchant_name: tx.merchant || tx.description || null,
          description: tx.description || null,
          amount: Math.abs(amtNum),
          currency: card.currency || 'EUR',
          transaction_type: isPurchase ? 'purchase' : 'payment',
          installments: 1,
          installment_number: 1,
        }
      })

      const { data: inserted, error: insErr } = await supabase
        .from('credit_card_transactions')
        .insert(toInsert)
        .select()
      if (insErr) {
        console.error('Erro ao inserir transa√ß√µes de cart√£o:', insErr)
        return NextResponse.json({ error: 'Erro ao salvar transa√ß√µes' }, { status: 500 })
      }

      // Atualizar saldo do cart√£o (compras somam; pagamentos subtraem)
  const delta = toInsert.reduce((sum: number, r: any) => sum + (r.transaction_type === 'purchase' ? r.amount : -r.amount), 0 as number)
      const newBalance = (card.current_balance || 0) + delta
      const { error: updErr } = await supabase
        .from('credit_cards')
        .update({ current_balance: newBalance })
        .eq('id', creditCardId)
        .eq('user_id', user.id)
      if (updErr) console.error('Falha ao atualizar saldo do cart√£o:', updErr)

      return NextResponse.json({
        success: true,
        message: `${(inserted as any[]).length} transa√ß√µes de cart√£o adicionadas com sucesso`,
        transactions: inserted,
      })
    }

    // ===== MODO RECIBOS: Processa documentos de compra salvando apenas dados essenciais =====
    // Foco: nome, data, total (SEM salvar imagens)
    if (String(target) === 'rec') {
      console.log('üìÑ Processando documento como RECIBO (dados essenciais apenas)...')
      
      try {
        // 1. Extrair informa√ß√µes essenciais do recibo
        const receiptData = extractReceiptEssentials(transactions, receipts)
        console.log('üìã Dados essenciais extra√≠dos:', receiptData)

        // 2. Salvar recibo principal (apenas dados, sem imagem)
        const { data: savedReceipt, error: receiptError } = await supabase
          .from('receipts')
          .insert({
            user_id: user.id,
            merchant_name: receiptData.merchantName,
            receipt_date: receiptData.date,
            subtotal: receiptData.subtotal,
            tax: receiptData.tax,
            total: receiptData.total,
            currency: receiptData.currency,
            notes: `Recibo processado automaticamente - ${receiptData.itemCount} item(s)`
          })
          .select('id')
          .single()

        if (receiptError) {
          console.error('‚ùå Erro ao salvar recibo:', receiptError)
          return NextResponse.json({ error: 'Erro ao salvar recibo' }, { status: 500 })
        }

        const receiptId = savedReceipt.id
        let receiptsSaved = 1
        let transactionsSaved = 0
        console.log('‚úÖ Recibo salvo com ID:', receiptId)

        return NextResponse.json({
          success: true,
          message: `Recibo processado! ${receiptsSaved} recibo(s) salvos na p√°gina de recibos.`,
          receiptId,
          receiptsSaved,
          transactionsSaved,
          data: {
            merchantName: receiptData.merchantName,
            date: receiptData.date,
            total: receiptData.total,
            itemCount: receiptData.itemCount
          }
        })

      } catch (error) {
        console.error('‚ùå Erro no processamento do recibo:', error)
        return NextResponse.json({ error: 'Erro ao processar recibo' }, { status: 500 })
      }
    }
      let receiptsSaved = 0
      let transactionsSaved = 0
      let receiptId: string | null = null // Declarar no escopo correto
      
      // Primeiro, salvar transa√ß√µes como transa√ß√µes normais se houver
      if (Array.isArray(transactions) && transactions.length > 0) {
        // Criar uma conta padr√£o se o usu√°rio n√£o tiver nenhuma
        let defaultAccountId = null
        const { data: userAccounts } = await supabase
          .from('accounts')
          .select('id, name')
          .eq('user_id', user.id)
          .order('created_at', { ascending: true })
          .limit(1)
          
        if (userAccounts && userAccounts.length > 0) {
          defaultAccountId = userAccounts[0].id
          console.log('PDF Confirm - Usando conta existente:', userAccounts[0].name)
        } else {
          // Criar conta padr√£o para recibos
          const { data: newAccount, error: accountError } = await supabase
            .from('accounts')
            .insert({
              user_id: user.id,
              account_name: 'Conta Principal',
              account_type: 'checking',
              currency: 'EUR',
              balance: 0
            })
            .select('id')
            .single()
            
          if (!accountError && newAccount) {
            defaultAccountId = newAccount.id
            console.log('PDF Confirm - Conta criada automaticamente para recibos')
          }
        }
        
        if (defaultAccountId) {
          // Sempre criar um recibo para agrupar as transa√ß√µes
          const mainReceipt = (Array.isArray(receipts) && receipts.length > 0) 
            ? receipts[0] 
            : {
                merchant: 'Estabelecimento',
                date: new Date().toISOString().split('T')[0],
                total: transactions.reduce((sum, t) => sum + Math.abs(parseFloat(t.amount)), 0)
              }
              
          try {
            console.log('PDF Confirm - Salvando recibo principal:', mainReceipt)
            const { data: receiptRow, error: recErr } = await supabase
              .from('receipts')
              .insert({
                user_id: user.id,
                account_id: defaultAccountId,
                merchant_name: mainReceipt.merchant || 'Estabelecimento',
                receipt_date: mainReceipt.date || new Date().toISOString().split('T')[0],
                subtotal: typeof mainReceipt.subtotal === 'number' ? mainReceipt.subtotal : null,
                tax: typeof mainReceipt.tax === 'number' ? mainReceipt.tax : null,
                total: typeof mainReceipt.total === 'number' ? mainReceipt.total : null,
              })
              .select('id')
              .single()

            if (!recErr && receiptRow?.id) {
              receiptId = receiptRow.id
              receiptsSaved = 1
              console.log('PDF Confirm - Recibo principal salvo com ID:', receiptId)
            } else {
              console.error('PDF Confirm - Erro ao salvar recibo:', recErr)
              console.log('PDF Confirm - Dados do recibo tentado:', mainReceipt)
            }
          } catch (e) {
            console.error('PDF Confirm - Erro ao salvar recibo principal:', e)
          }

          // Buscar categorias para mapear
          const { data: categories } = await supabase
            .from('categories')
            .select('id, name')

          const categoryMap = new Map(categories?.map(cat => [cat.name.toLowerCase(), cat.id]) || [])
          
          const transactionsToInsert = transactions.map((transaction: any) => {
            let categoryId = null
            
            if (transaction.suggestedCategory) {
              const suggestedLower = transaction.suggestedCategory.toLowerCase()
              categoryId = categoryMap.get(suggestedLower)
              
              // Busca parcial se n√£o encontrar exata
              if (!categoryId) {
                for (const [catName, catId] of categoryMap.entries()) {
                  if (catName.includes(suggestedLower) || suggestedLower.includes(catName)) {
                    categoryId = catId
                    break
                  }
                }
              }
            }

            const amt = parseFloat(transaction.amount)
            // Para recibos, valores s√£o negativos (despesas)
            const finalAmount = -Math.abs(amt)
            
            console.log('PDF Confirm - Preparando transa√ß√£o com receiptId:', receiptId)
            
            return {
              user_id: user.id,
              account_id: defaultAccountId,
              receipt_id: receiptId, // Link para o recibo
              amount: finalAmount,
              description: transaction.description,
              category_id: categoryId,
              transaction_date: transaction.date,
              currency: 'EUR',
              type: 'expense',
              created_at: new Date().toISOString(),
            }
          })

          console.log('PDF Confirm - Transa√ß√µes preparadas para inserir:')
          console.log('PDF Confirm - Receipt ID que ser√° usado:', receiptId)
          console.log('PDF Confirm - Primeira transa√ß√£o exemplo:', JSON.stringify(transactionsToInsert[0], null, 2))

          const { data: insertedTransactions, error: insertError } = await supabase
            .from('transactions')
            .insert(transactionsToInsert)
            .select()

          if (!insertError && insertedTransactions) {
            transactionsSaved = insertedTransactions.length
            console.log('PDF Confirm - Transa√ß√µes de recibo salvas:', transactionsSaved)
            console.log('PDF Confirm - Primeira transa√ß√£o salva:', JSON.stringify(insertedTransactions[0], null, 2))
          } else {
            console.error('PDF Confirm - Erro ao inserir transa√ß√µes:', insertError)
          }
        }
      }
      
      // Salvar itens detalhados do recibo se existirem
      if (receiptId && Array.isArray(receipts) && receipts.length > 0) {
        const mainReceipt = receipts[0]
        if (Array.isArray(mainReceipt.items)) {
          try {
            const itemsToInsert = mainReceipt.items.map((it: any, index: number) => ({
              user_id: user.id,
              receipt_id: receiptId,
              line_no: index + 1,
              description: String(it.description || 'Item'),
              quantity: typeof it.quantity === 'number' ? it.quantity : null,
              unit_price: typeof it.unitPrice === 'number' ? it.unitPrice : null,
              tax_rate: typeof it.taxRate === 'number' ? it.taxRate : null,
              tax_amount: typeof it.taxAmount === 'number' ? it.taxAmount : null,
              total: typeof it.total === 'number' ? it.total : null,
              sku: it.code ? String(it.code) : null,
            }))
            await supabase.from('receipt_items').insert(itemsToInsert)
            console.log('PDF Confirm - Itens do recibo salvos:', itemsToInsert.length)
          } catch (e) {
            console.error('PDF Confirm - Erro ao salvar itens do recibo:', e)
          }
        }
      }

      return NextResponse.json({
        success: true,
        message: `Recibos: ${receiptsSaved}, Transa√ß√µes: ${transactionsSaved}`,
        receiptsSaved,
        transactionsSaved
      })
    }

    return NextResponse.json({ error: 'Destino inv√°lido' }, { status: 400 })

  } catch (error) {
    console.error('Erro ao confirmar transa√ß√µes:', error)
    return NextResponse.json(
      { error: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
