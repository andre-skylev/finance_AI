import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    
    // Verificar autenticação
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Não autorizado' }, { status: 401 })
    }

  const { transactions, target, receipts } = await request.json()

  console.log('PDF Confirm - Dados recebidos:', { 
    transactionsCount: transactions?.length, 
    target, 
    receiptsCount: receipts?.length,
    userId: user.id
  })
  console.log('PDF Confirm - Transações:', JSON.stringify(transactions, null, 2))

  if ((!transactions || !Array.isArray(transactions)) && !(target && String(target).startsWith('rec'))) {
      return NextResponse.json({ error: 'Dados inválidos' }, { status: 400 })
    }
    // Roteamento por destino: conta bancária (acc:ID) ou cartão de crédito (cc:ID)
    if (typeof target === 'string' && target.startsWith('acc:')) {
      const accountId = target.slice(4)
      // Verificar se a conta pertence ao usuário
      const { data: account, error: accountError } = await supabase
        .from('accounts')
        .select('id, name, currency')
        .eq('id', accountId)
        .eq('user_id', user.id)
        .single()

      if (accountError || !account) {
        return NextResponse.json({ error: 'Conta não encontrada' }, { status: 404 })
      }

      // Buscar categorias para mapear
      const { data: categories } = await supabase
        .from('categories')
        .select('id, name')

      console.log('PDF Confirm - Categorias encontradas:', categories?.length)
      const categoryMap = new Map(categories?.map(cat => [cat.name.toLowerCase(), cat.id]) || [])
      console.log('PDF Confirm - Mapa de categorias:', Array.from(categoryMap.entries()))

      // Preparar transações para inserção
      const transactionsToInsert = transactions.map((transaction: any) => {
        // Mapear categoria sugerida para ID
        let categoryId = null
        if (transaction.suggestedCategory) {
          const suggestedLower = String(transaction.suggestedCategory).toLowerCase()
          console.log('PDF Confirm - Procurando categoria:', suggestedLower)
          
          // Busca exata primeiro
          if (categoryMap.has(suggestedLower)) {
            categoryId = categoryMap.get(suggestedLower)
            console.log('PDF Confirm - Categoria encontrada (exata):', categoryId)
          } else {
            // Busca parcial
            for (const [catName, catId] of categoryMap.entries()) {
              if (catName.includes(suggestedLower) || suggestedLower.includes(catName)) {
                categoryId = catId
                console.log('PDF Confirm - Categoria encontrada (parcial):', catName, '->', categoryId)
                break
              }
            }
          }
          
          if (!categoryId) {
            console.log('PDF Confirm - Categoria não encontrada para:', suggestedLower)
          }
        }

        const amt = parseFloat(transaction.amount)
        return {
          user_id: user.id,
          account_id: accountId,
          amount: amt,
          description: transaction.description,
          category_id: categoryId,
          transaction_date: transaction.date,
          currency: account?.currency || 'EUR',
          type: amt >= 0 ? 'income' : 'expense',
          created_at: new Date().toISOString(),
        }
      })

      console.log('PDF Confirm - Transações preparadas para inserção:', JSON.stringify(transactionsToInsert, null, 2))

      const { data: insertedTransactions, error: insertError } = await supabase
        .from('transactions')
        .insert(transactionsToInsert)
        .select()

      console.log('PDF Confirm - Resultado da inserção:', { insertedTransactions, insertError })

      if (insertError) {
        console.error('Erro ao inserir transações:', insertError)
        return NextResponse.json({ error: 'Erro ao salvar transações' }, { status: 500 })
      }

      // Salvar recibos vinculados à conta (opcional)
      let receiptsSaved = 0
      if (Array.isArray(receipts) && receipts.length > 0) {
        for (const r of receipts) {
          try {
            // Associar por total e data
            let matchedTxId: string | null = null
            if (Array.isArray(insertedTransactions) && typeof r.total === 'number') {
              const sameDay = (a?: string, b?: string) => {
                if (!a || !b) return false
                const da = new Date(a).toISOString().slice(0,10)
                const db = new Date(b).toISOString().slice(0,10)
                return da === db
              }
              const found = insertedTransactions.find((tx: any) => {
                const amtEqual = Number(tx.amount) === Number(r.total)
                const dateEqual = sameDay(tx.date || tx.transaction_date, r.date)
                return amtEqual && dateEqual
              })
              matchedTxId = found?.id || null
            }

            const { data: receiptRow, error: recErr } = await supabase
              .from('receipts')
              .insert({
                user_id: user.id,
                account_id: accountId,
                transaction_id: matchedTxId,
                merchant_name: r.merchant || null,
                receipt_date: r.date || null,
                subtotal: typeof r.subtotal === 'number' ? r.subtotal : null,
                tax: typeof r.tax === 'number' ? r.tax : null,
                total: typeof r.total === 'number' ? r.total : null,
              })
              .select('id')
              .single()

            if (!recErr && receiptRow?.id && Array.isArray(r.items)) {
              const itemsToInsert = r.items.map((it: any, index: number) => ({
                user_id: user.id,
                receipt_id: receiptRow.id,
                line_no: index + 1,
                description: String(it.description || 'Item'),
                quantity: typeof it.quantity === 'number' ? it.quantity : null,
                unit_price: typeof it.unitPrice === 'number' ? it.unitPrice : null,
                tax_rate: typeof it.taxRate === 'number' ? it.taxRate : null,
                tax_amount: typeof it.taxAmount === 'number' ? it.taxAmount : null,
                total: typeof it.total === 'number' ? it.total : null,
                sku: it.code ? String(it.code) : null,
              }))
              const { error: itemsErr } = await supabase
                .from('receipt_items')
                .insert(itemsToInsert)
              if (itemsErr) console.error('Erro ao inserir itens do recibo:', itemsErr)
            }
            receiptsSaved++
          } catch (e) {
            console.error('Falha ao salvar recibo:', e)
          }
        }
      }

      return NextResponse.json({
        success: true,
        message: `${(insertedTransactions as any[]).length} transações adicionadas com sucesso${receiptsSaved ? `, ${receiptsSaved} recibo(s) salvo(s)` : ''}`,
        transactions: insertedTransactions,
        receiptsSaved
      })
    }

    if (typeof target === 'string' && target.startsWith('cc:')) {
      const creditCardId = target.slice(3)
      // Verificar se o cartão pertence ao usuário
      const { data: card, error: cardErr } = await supabase
        .from('credit_cards')
        .select('id, currency, current_balance')
        .eq('id', creditCardId)
        .eq('user_id', user.id)
        .single()
      if (cardErr || !card) {
        return NextResponse.json({ error: 'Cartão não encontrado' }, { status: 404 })
      }

      // Preparar transações de cartão (uso positivo; distinguir compra/pagamento pelo sinal)
      const toInsert = transactions.map((tx: any) => {
        const amtNum = Number(tx.amount)
        const isPurchase = amtNum >= 0
        return {
          user_id: user.id,
          credit_card_id: creditCardId,
          transaction_date: tx.date,
          merchant_name: tx.merchant || tx.description || null,
          description: tx.description || null,
          amount: Math.abs(amtNum),
          currency: card.currency || 'EUR',
          transaction_type: isPurchase ? 'purchase' : 'payment',
          installments: 1,
          installment_number: 1,
        }
      })

      const { data: inserted, error: insErr } = await supabase
        .from('credit_card_transactions')
        .insert(toInsert)
        .select()
      if (insErr) {
        console.error('Erro ao inserir transações de cartão:', insErr)
        return NextResponse.json({ error: 'Erro ao salvar transações' }, { status: 500 })
      }

      // Atualizar saldo do cartão (compras somam; pagamentos subtraem)
  const delta = toInsert.reduce((sum: number, r: any) => sum + (r.transaction_type === 'purchase' ? r.amount : -r.amount), 0 as number)
      const newBalance = (card.current_balance || 0) + delta
      const { error: updErr } = await supabase
        .from('credit_cards')
        .update({ current_balance: newBalance })
        .eq('id', creditCardId)
        .eq('user_id', user.id)
      if (updErr) console.error('Falha ao atualizar saldo do cartão:', updErr)

      return NextResponse.json({
        success: true,
        message: `${(inserted as any[]).length} transações de cartão adicionadas com sucesso`,
        transactions: inserted,
      })
    }

    // Receipts mode, target === 'rec'
    // Salva os recibos E as transações extraídas dos itens
    if (String(target) === 'rec') {
      let receiptsSaved = 0
      let transactionsSaved = 0
      
      // Primeiro, criar uma conta padrão se o usuário não tiver nenhuma
      let defaultAccountId = null
      const { data: userAccounts } = await supabase
        .from('accounts')
        .select('id, name')
        .eq('user_id', user.id)
        .order('created_at', { ascending: true })
        .limit(1)
        
      if (userAccounts && userAccounts.length > 0) {
        defaultAccountId = userAccounts[0].id
        console.log('PDF Confirm - Usando conta existente:', userAccounts[0].name)
      } else {
        // Criar conta padrão para recibos
        const { data: newAccount, error: accountError } = await supabase
          .from('accounts')
          .insert({
            user_id: user.id,
            account_name: 'Conta Principal',
            account_type: 'checking',
            currency: 'EUR',
            balance: 0
          })
          .select('id')
          .single()
          
        if (!accountError && newAccount) {
          defaultAccountId = newAccount.id
          console.log('PDF Confirm - Conta criada automaticamente para recibos')
        }
      }
      
      // Salvar transações de recibos como transações normais
      if (Array.isArray(transactions) && transactions.length > 0 && defaultAccountId) {
        // Primeiro, salvar o recibo se houver dados
        let receiptHeaderId = null
        if (Array.isArray(receipts) && receipts.length > 0) {
          const firstReceipt = receipts[0]
          const { data: receiptRow, error: recErr } = await supabase
            .from('receipts')
            .insert({
              user_id: user.id,
              account_id: defaultAccountId,
              transaction_id: null, // Will be updated later
              merchant_name: firstReceipt.merchant || 'Estabelecimento',
              receipt_date: firstReceipt.date || new Date().toISOString().split('T')[0],
              subtotal: typeof firstReceipt.subtotal === 'number' ? firstReceipt.subtotal : null,
              tax: typeof firstReceipt.tax === 'number' ? firstReceipt.tax : null,
              total: typeof firstReceipt.total === 'number' ? firstReceipt.total : null,
            })
            .select('id')
            .single()
            
          if (!recErr && receiptRow) {
            receiptHeaderId = receiptRow.id
            receiptsSaved = 1
            console.log('PDF Confirm - Recibo header criado:', receiptHeaderId)
          }
        }
        
        // Buscar categorias para mapear
        const { data: categories } = await supabase
          .from('categories')
          .select('id, name')

        const categoryMap = new Map(categories?.map(cat => [cat.name.toLowerCase(), cat.id]) || [])
        
        const transactionsToInsert = transactions.map((transaction: any) => {
          let categoryId = null
          
          if (transaction.suggestedCategory) {
            const suggestedLower = transaction.suggestedCategory.toLowerCase()
            categoryId = categoryMap.get(suggestedLower)
            
            // Busca parcial se não encontrar exata
            if (!categoryId) {
              for (const [catName, catId] of categoryMap.entries()) {
                if (catName.includes(suggestedLower) || suggestedLower.includes(catName)) {
                  categoryId = catId
                  break
                }
              }
            }
          }

          const amt = parseFloat(transaction.amount)
          return {
            user_id: user.id,
            account_id: defaultAccountId,
            amount: amt,
            description: transaction.description,
            category_id: categoryId,
            transaction_date: transaction.date,
            currency: 'EUR',
            type: amt >= 0 ? 'income' : 'expense',
            created_at: new Date().toISOString(),
            receipt_id: receiptHeaderId, // Vincular ao recibo se houver
          }
        })

        const { data: insertedTransactions, error: insertError } = await supabase
          .from('transactions')
          .insert(transactionsToInsert)
          .select()

        if (!insertError && insertedTransactions) {
          transactionsSaved = insertedTransactions.length
          console.log('PDF Confirm - Transações de recibo salvas:', transactionsSaved)
          
          // Se há um recibo header, salvar os itens também
          if (receiptHeaderId && Array.isArray(receipts) && receipts[0]?.items) {
            const itemsToInsert = receipts[0].items.map((it: any, index: number) => ({
              user_id: user.id,
              receipt_id: receiptHeaderId,
              line_no: index + 1,
              description: String(it.description || 'Item'),
              quantity: typeof it.quantity === 'number' ? it.quantity : null,
              unit_price: typeof it.unitPrice === 'number' ? it.unitPrice : null,
              tax_rate: typeof it.taxRate === 'number' ? it.taxRate : null,
              tax_amount: typeof it.taxAmount === 'number' ? it.taxAmount : null,
              total: typeof it.total === 'number' ? it.total : null,
              sku: it.code ? String(it.code) : null,
            }))
            await supabase.from('receipt_items').insert(itemsToInsert)
            console.log('PDF Confirm - Itens do recibo salvos:', itemsToInsert.length)
          }
        }
      }
      
      // Remover o bloco antigo de salvar recibos separadamente
        for (const r of receipts) {
          try {
            const { data: receiptRow, error: recErr } = await supabase
              .from('receipts')
              .insert({
                user_id: user.id,
                account_id: null,
                transaction_id: null,
                merchant_name: r.merchant || null,
                receipt_date: r.date || null,
                subtotal: typeof r.subtotal === 'number' ? r.subtotal : null,
                tax: typeof r.tax === 'number' ? r.tax : null,
                total: typeof r.total === 'number' ? r.total : null,
              })
              .select('id')
              .single()

            if (!recErr && receiptRow?.id && Array.isArray(r.items)) {
              const itemsToInsert = r.items.map((it: any, index: number) => ({
                user_id: user.id,
                receipt_id: receiptRow.id,
                line_no: index + 1,
                description: String(it.description || 'Item'),
                quantity: typeof it.quantity === 'number' ? it.quantity : null,
                unit_price: typeof it.unitPrice === 'number' ? it.unitPrice : null,
          }
        }
      }
      
      return NextResponse.json({
        success: true,
        message: `${transactionsSaved} transação(ões) e ${receiptsSaved} recibo(s) salvo(s)`,
        transactionsSaved,
        receiptsSaved
      })
    }

    return NextResponse.json({ error: 'Destino inválido' }, { status: 400 })

  } catch (error) {
    console.error('Erro ao confirmar transações:', error)
    return NextResponse.json(
      { error: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
