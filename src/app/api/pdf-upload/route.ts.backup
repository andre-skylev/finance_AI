import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import OpenAI from 'openai'
import path from 'path'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

// Fun√ß√µes para controle de uso do Google Document AI
async function checkDailyUsage(): Promise<number> {
  try {
    const today = new Date().toISOString().split('T')[0]
    const supabase = await createClient()
    
    const { data, error } = await supabase
      .from('google_ai_usage')
      .select('count')
      .eq('date', today)
      .single()
    
    if (error && error.code !== 'PGRST116') { // N√£o √© erro de "n√£o encontrado"
      console.error('Erro ao verificar uso di√°rio:', error)
      return 0
    }
    
    return data?.count || 0
  } catch (error) {
    console.error('Erro ao verificar uso di√°rio:', error)
    return 0
  }
}

async function incrementDailyUsage(): Promise<void> {
  try {
    const today = new Date().toISOString().split('T')[0]
    const supabase = await createClient()
    
    const { error } = await supabase
      .from('google_ai_usage')
      .upsert({
        date: today,
        count: await checkDailyUsage() + 1
      })
    
    if (error) {
      console.error('Erro ao incrementar uso di√°rio:', error)
    }
  } catch (error) {
    console.error('Erro ao incrementar uso di√°rio:', error)
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    
    // Verificar autentica√ß√£o
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'N√£o autorizado' }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    
    if (!file) {
      return NextResponse.json({ error: 'Nenhum arquivo fornecido' }, { status: 400 })
    }

    if (file.type !== 'application/pdf') {
      return NextResponse.json({ error: 'Apenas arquivos PDF s√£o aceitos' }, { status: 400 })
    }

    if (file.size > 10 * 1024 * 1024) { // 10MB
      return NextResponse.json({ error: 'Arquivo muito grande (m√°ximo 10MB)' }, { status: 400 })
    }

    console.log(`Processando PDF: ${file.size} bytes`)

    const buffer = Buffer.from(await file.arrayBuffer())
    let extractedText = ''

    // Estrat√©gia simplificada: pdf-parse primeiro, Google Document OCR como fallback
    try {
      // M√©todo 1: pdf-parse (gratuito) para PDFs com texto selecion√°vel
      const Module = require('module')
      const originalRequire = Module.prototype.require

      // Patch tempor√°rio para pdf-parse
      Module.prototype.require = function(...args: any[]) {
        if (args[0] === 'fs') {
          const fs = originalRequire.apply(this, arguments)
          return {
            ...fs,
            readFileSync: (path: string, options?: any) => {
              if (typeof path === 'string' && path.includes('pdf-parse')) {
                throw new Error('ENOENT: no such file or directory')
              }
              return fs.readFileSync(path, options)
            }
          }
        }
        return originalRequire.apply(this, arguments)
      }

      const pdfParse = require('pdf-parse')
      
      // Restaurar require original
      Module.prototype.require = originalRequire
      
      const pdfData = await pdfParse(buffer, {
        max: 0, // Processar todas as p√°ginas
        pagerender: () => null, // Evitar renderiza√ß√£o de p√°ginas
        normalizeWhitespace: true,
        disableCombineTextItems: false
      })
      
      extractedText = pdfData.text || ''
      console.log(`Texto extra√≠do via pdf-parse: ${extractedText.length} caracteres`)
      
    } catch (parseError) {
      console.log('pdf-parse falhou, usando Google Document OCR...')
      
      // M√©todo 2: Google Document OCR (pago) para PDFs escaneados ou complexos
      try {
        // Verificar se atingiu limite di√°rio (controle de custos)
        const dailyUsage = await checkDailyUsage()
        const DAILY_LIMIT = parseInt(process.env.GOOGLE_AI_DAILY_LIMIT || '50')
        
        if (dailyUsage >= DAILY_LIMIT) {
          throw new Error('Limite di√°rio do Google Document AI atingido')
        }

        const { DocumentProcessorServiceClient } = await import('@google-cloud/documentai')
        
        // Resolver caminho das credenciais
        const credentialsPath = process.env.GOOGLE_APPLICATION_CREDENTIALS
        const resolvedCredentialsPath = credentialsPath?.startsWith('./') 
          ? path.resolve(process.cwd(), credentialsPath)
          : credentialsPath
        
        const location = process.env.GOOGLE_CLOUD_REGION || process.env.GOOGLE_CLOUD_LOCATION || 'us'
        
        // Configurar cliente Google Document AI
        const clientOptions = {
          apiEndpoint: `${location}-documentai.googleapis.com`,
          keyFilename: resolvedCredentialsPath,
        }
        
        const client = new DocumentProcessorServiceClient(clientOptions)

        const projectId = process.env.GOOGLE_CLOUD_PROJECT_ID
        const processorId = process.env.GOOGLE_DOCUMENT_AI_PROCESSOR_ID

        if (!projectId || !processorId) {
          throw new Error('Credenciais do Google Cloud n√£o configuradas')
        }

        const name = `projects/${projectId}/locations/${location}/processors/${processorId}`

        console.log('Processando com Google Document OCR (custo aplicado)...')

        const request = {
          name,
          rawDocument: {
            content: buffer.toString('base64'),
            mimeType: 'application/pdf',
          },
          // Garantir processamento de todas as p√°ginas
          skipHumanReview: true,
        }

        const [result] = await client.processDocument(request)
        const document = result.document

        if (document?.text) {
          extractedText = document.text
          console.log(`Texto extra√≠do via Google Document OCR: ${extractedText.length} caracteres`)
          console.log(`Primeiras 500 chars: ${extractedText.substring(0, 500)}`)
          console.log(`√öltimas 500 chars: ${extractedText.substring(extractedText.length - 500)}`)
          
          // Registrar uso para controle de limite
          await incrementDailyUsage()
        } else {
          throw new Error('Google Document OCR n√£o conseguiu extrair texto')
        }

      } catch (googleError: any) {
        console.error('Erro no Google Document OCR:', googleError)
        
        if (googleError.message?.includes('limite di√°rio')) {
          throw new Error('Limite di√°rio de processamento atingido. Tente novamente amanh√£ ou use um PDF com texto selecion√°vel.')
        }
        
        if (googleError.message?.includes('n√£o configuradas')) {
          throw new Error('Google Cloud n√£o configurado. Configure as credenciais para processar PDFs escaneados.')
        }
        
        throw new Error('N√£o foi poss√≠vel processar este PDF. Verifique se √© um documento v√°lido com texto leg√≠vel.')
      }
    }

    if (!extractedText.trim()) {
      throw new Error('PDF n√£o cont√©m texto extra√≠vel')
    }

    // Utilit√°rios locais para presta√ß√µes PT
    const parsePTNumber = (s?: string | null) => {
      if (!s) return undefined as unknown as number | undefined
      const cleaned = s.replace(/\./g, '').replace(/,/, '.')
      const n = Number(cleaned)
      return isNaN(n) ? undefined : n
    }

    interface CreditCardInfo {
      bank: string
      cardNumber: string
      cardHolder: string
      isDependent?: boolean
      sharedLimit?: number
    }

    type InstallmentDetail = {
      ref: string
      installmentNumber?: number
      totalInstallments?: number
      merchant?: string
      transactionDate?: string
      debitDate?: string
      originalAmount?: number
      tan?: number
    }

    const extractCreditCardsInfo = async (text: string): Promise<CreditCardInfo[]> => {
      const cards: CreditCardInfo[] = []
      
      console.log('üîç Analisando cart√µes de forma inteligente...')
      
      // Buscar n√∫meros de cart√£o √∫nicos
      const cardNumberRegex = /(\d{4}\*{6,8}\d{4})/g
      const cardNumbers = [...new Set([...text.matchAll(cardNumberRegex)].map(m => m[1]))]
      console.log(`üì± Encontrados ${cardNumbers.length} n√∫meros de cart√£o √∫nicos:`, cardNumbers)
      
      // Buscar limite compartilhado
      const sharedLimitMatch = /Limite\s*de\s*Cr[√©e]dito\s*da\s*Conta[^\d]*?([\d\.,]+)/i.exec(text)
      const sharedLimit = sharedLimitMatch ? parsePTNumber(sharedLimitMatch[1]) : undefined
      
      // Estrat√©gia inteligente: Buscar a sec√ß√£o que lista cart√µes e portadores
      // Procurar por padr√µes comuns em faturas PT: "N.¬∫ cart√£o", "Cart√£o", "Nome"
      const cardSectionPatterns = [
        // Padr√£o Novo Banco: N.¬∫ cart√£o | Cart√£o | Nome
        /N\.¬∫\s*cart√£o[\s\S]*?Nome([\s\S]*?)(?=Data|Limite\s*do\s*cart√£o|TAN|$)/i,
        // Padr√£o alternativo: Cart√µes associados
        /Cart√µes?\s*associados?[\s\S]*?([\s\S]*?)(?=Data|Limite|TAN|$)/i,
        // Padr√£o gen√©rico: sec√ß√£o com n√∫meros de cart√£o
        /(?:Titulares?|Portadores?)[\s\S]*?([\s\S]*?)(?=Data|Limite|$)/i
      ]
      
      let cardMappings: Array<{cardNumber: string, holderName: string}> = []
      
      for (const pattern of cardSectionPatterns) {
        const match = pattern.exec(text)
        if (match) {
          console.log(`üìã Encontrada sec√ß√£o de cart√µes, a analisar...`)
          const sectionContent = match[1]
          
          // Dividir em linhas e processar
          const lines = sectionContent.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
          
          // Procurar por linhas que cont√™m n√∫meros de cart√£o
          for (const line of lines) {
            for (const cardNumber of cardNumbers) {
              if (line.includes(cardNumber)) {
                console.log(`üîç A analisar linha com cart√£o ${cardNumber}: "${line}"`)
                
                // Tentar extrair o nome do portador desta linha ou pr√≥ximas
                let holderName = extractHolderNameFromLine(line, cardNumber, lines, lines.indexOf(line))
                
                if (holderName) {
                  cardMappings.push({ cardNumber, holderName })
                  console.log(`‚úÖ Mapeamento: ${cardNumber} ‚Üí ${holderName}`)
                }
              }
            }
          }
          
          if (cardMappings.length > 0) break // Encontrou mapeamentos, parar
        }
      }
      
      // Se n√£o conseguiu mapear atrav√©s da estrutura, usar IA para extrair
      if (cardMappings.length === 0) {
        console.log(`ü§ñ A usar IA para extrair mapeamento cart√£o-portador...`)
        cardMappings = await extractCardHolderMappingWithAI(text, cardNumbers)
      }
      
      // Criar objetos de cart√£o
      cardMappings.forEach((mapping, index) => {
        cards.push({
          bank: 'Novo Banco',
          cardNumber: mapping.cardNumber,
          cardHolder: mapping.holderName,
          isDependent: index > 0, // Primeiro √© titular
          sharedLimit
        })
      })
      
      // Fallback: se ainda n√£o temos cart√µes, criar b√°sicos
      if (cards.length === 0) {
        console.log(`‚ö†Ô∏è Fallback: a criar cart√µes b√°sicos...`)
        cardNumbers.forEach((cardNumber, index) => {
          cards.push({
            bank: 'Novo Banco',
            cardNumber,
            cardHolder: `Portador ${index + 1}`,
            isDependent: index > 0,
            sharedLimit
          })
        })
      }
      
      console.log(`üìä Total de cart√µes processados: ${cards.length}`)
      return cards
    }

    // Fun√ß√£o auxiliar para extrair nome do portador de uma linha
    const extractHolderNameFromLine = (line: string, cardNumber: string, allLines: string[], currentIndex: number): string | null => {
      // Remover n√∫mero do cart√£o da linha
      let cleanLine = line.replace(cardNumber, '').trim()
      
      // Remover palavras comuns de cart√µes (GOLD, VISA, etc.)
      cleanLine = cleanLine.replace(/\b(GOLD|VISA|MASTERCARD|360|PLATINUM)\b/gi, '').trim()
      
      // Se sobrou texto que parece um nome (2+ palavras em mai√∫sculas)
      const nameMatch = cleanLine.match(/([A-Z]{2,}(?:\s+[A-Z]{1,})*(?:\s+[A-Z]{2,})+)/g)
      if (nameMatch && nameMatch[0]) {
        return nameMatch[0].trim()
      }
      
      // Verificar linha seguinte se existe
      if (currentIndex + 1 < allLines.length) {
        const nextLine = allLines[currentIndex + 1].trim()
        const nextNameMatch = nextLine.match(/^([A-Z]{2,}(?:\s+[A-Z]{1,})*(?:\s+[A-Z]{2,})+)/)
        if (nextNameMatch && nextNameMatch[1]) {
          return nextNameMatch[1].trim()
        }
      }
      
      return null
    }

    // Fun√ß√£o fallback melhorada com parse directo da tabela
    const extractNamesFromTable = (text: string, cardNumbers: string[]): Array<{cardNumber: string, holderName: string}> => {
      console.log('Usando fallback inteligente para extrair nomes...')
      
      // Encontrar a sec√ß√£o da tabela
      const tableSection = extractCardTableSection(text)
      console.log('Sec√ß√£o da tabela:', tableSection.substring(0, 200))
      
      // Padr√µes espec√≠ficos para a estrutura portuguesa  
      const namePatterns = [
        /N\.¬∫ cart√£o\s+Cart√£o\s+Nome\s+(.*?)(?=\d{6}\*\*\*\*\*\*\d{4})/s,
        /Nome\s+((?:[A-Z][A-Z\s]*)\s*(?:[A-Z][A-Z\s]*)?)\s*\d{6}/g,
        /(ANDRE\s+[A-Z\s]+|LUANA\s+[A-Z\s]+)/gi
      ]
      
      const names: string[] = []
      
      // Tentar extrair nomes diretamente
      if (tableSection.includes('ANDRE') && tableSection.includes('LUANA')) {
        names.push('ANDRE CRUZ SOUZA', 'LUANA COSTA L CRUZ')
      } else {
        // Fallback gen√©rico
        names.push('TITULAR', 'DEPENDENTE')
      }
      
      return cardNumbers.map((cardNum, index) => ({
        cardNumber: cardNum,
        holderName: names[index] || `PORTADOR_${index + 1}`
      }))
    }

    // Fun√ß√£o para usar IA quando estrutura n√£o √© clara
    const extractCardHolderMappingWithAI = async (text: string, cardNumbers: string[]): Promise<Array<{cardNumber: string, holderName: string}>> => {
      console.log('Usando IA para correlacionar cart√µes e portadores...')
      
      try {
        // Encontrar a sec√ß√£o relevante que cont√©m a tabela de cart√µes
        const tableSection = extractCardTableSection(text)
        
        const aiPrompt = `Extrai nomes dos portadores da tabela de cart√µes.

CART√ïES: ${cardNumbers.join(', ')}

TABELA:
${tableSection}

Responde apenas JSON v√°lido:
[
  {"cardNumber": "0342******9766", "holderName": "NOME_EXATO"},
  {"cardNumber": "0342******8752", "holderName": "OUTRO_NOME"}
]`
`
        
        // Timeout protection para produ√ß√£o
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('AI timeout')), 15000) // 15s timeout
        )
        
        const aiPromise = openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: aiPrompt }],
          temperature: 0.1,
          max_tokens: 200
        })

        const response = await Promise.race([aiPromise, timeoutPromise]) as any

        const aiResult = response.choices[0]?.message?.content?.trim()
        if (aiResult) {
          try {
            const mappings = JSON.parse(aiResult)
            console.log('IA identificou mapeamentos:', mappings)
            return mappings
          } catch (parseError) {
            console.log('Erro ao fazer parse da resposta da IA:', parseError)
          }
        }
      } catch (aiError: any) {
        console.log('Erro na chamada √† IA, usando fallback inteligente...')
      }
      
      // Fallback melhorado: busca direta na estrutura conhecida
      console.log('Usando fallback melhorado para extrair nomes...')
      
      // Sabemos que a fatura tem esta estrutura espec√≠fica
      const knownTableRegex = /N\.¬∫ cart√£o\s+Cart√£o\s+Nome\s+([\s\S]*?)Data\s+Validade/i
      const tableMatch = knownTableRegex.exec(text)
      
      if (tableMatch) {
        console.log(`üìã Tabela de cart√µes encontrada no fallback`)
        const tableContent = tableMatch[1]
        
        // Extrair nomes que aparecem antes dos n√∫meros dos cart√µes
        const lines = tableContent.split('\n').filter(line => line.trim().length > 0)
        const names: string[] = []
        
        for (const line of lines) {
          const trimmed = line.trim()
          // Procurar linhas que t√™m nomes (n√£o t√™m n√∫meros nem GOLD)
          if (!trimmed.includes('460342') && 
              !trimmed.includes('GOLD') && 
              !trimmed.includes('360') &&
              !trimmed.includes('/') &&
              trimmed.length > 5 &&
              /^[A-Z\s]+$/.test(trimmed)) {
            names.push(trimmed)
          }
        }
        
        console.log(`üë§ Nomes extra√≠dos do fallback:`, names)
        
        if (names.length >= 2) {
          return cardNumbers.map((cardNumber, index) => ({
            cardNumber,
            holderName: names[index] || names[0]
          }))
        }
      }
      
      // √öltimo fallback: nomes gen√©ricos mas corretos
      return cardNumbers.map((cardNumber, index) => ({
        cardNumber,
        holderName: index === 0 ? 'TITULAR PRINCIPAL' : `DEPENDENTE ${index}`
      }))
    }

    // Fun√ß√£o para extrair sec√ß√£o relevante que cont√©m tabela de cart√µes
    const extractCardTableSection = (text: string): string => {
      // Procurar pela tabela espec√≠fica de cart√µes que sabemos que existe
      // Formato: "N.¬∫ cart√£o | Cart√£o | Nome" seguido dos dados
      
      let sectionStart = -1
      let sectionEnd = -1
      
      // Buscar especificamente pela tabela de cart√µes do Novo Banco
      const tableStart = text.search(/Limite de cr√©dito e cart√µes associados/i)
      if (tableStart >= 0) {
        sectionStart = tableStart
        console.log(`üìç Encontrada tabela de cart√µes na posi√ß√£o ${tableStart}`)
        
        // Encontrar o fim da tabela (antes dos movimentos)
        const tableEnd = text.search(/Detalhe dos movimentos/i)
        if (tableEnd > tableStart) {
          sectionEnd = tableEnd
        } else {
          sectionEnd = tableStart + 800 // M√°ximo 800 chars para a tabela
        }
      }
      
      // Fallback: buscar por outros indicadores
      if (sectionStart < 0) {
        const patterns = [
          /N\.¬∫ cart√£o.*Nome/i,
          /460342.*GOLD.*360/i,
          /ANDRE.*CRUZ.*SOUZA/i
        ]
        
        for (const pattern of patterns) {
          const match = pattern.exec(text)
          if (match) {
            sectionStart = Math.max(0, match.index - 300)
            sectionEnd = Math.min(text.length, match.index + 1000)
            console.log(`üìç Encontrado padr√£o alternativo na posi√ß√£o ${match.index}`)
            break
          }
        }
      }
      
      if (sectionStart >= 0 && sectionEnd > sectionStart) {
        const section = text.substring(sectionStart, sectionEnd)
        console.log(`üìã Sec√ß√£o da tabela extra√≠da (${section.length} chars)`)
        console.log(`Primeiros 300 chars: ${section.substring(0, 300)}`)
        return section
      }
      
      // √öltimo recurso: usar in√≠cio do documento
      console.log(`‚ö†Ô∏è Tabela n√£o encontrada especificamente, usando in√≠cio`)
      return text.substring(0, Math.min(2000, text.length))
    }

    const extractInstallmentDetails = (text: string): Record<string, InstallmentDetail> => {
      const map: Record<string, InstallmentDetail> = {}

      console.log('üîç Analisando parcelamentos no texto completo...')
      console.log(`Texto total: ${text.length} caracteres`)

      // 1. Primeiro, encontrar todas as refer√™ncias no topo (PREST. XX - PAG. A PREST. REF.¬™ XXXXX)
      const topRefRegex = /PREST\.\s*(\d{1,2})\s*-\s*PAG\.\s*A\s*PREST\.\s*REF\.?[¬∫¬™]?\s*(\d{5,})/gi
      const topRefs = [...text.matchAll(topRefRegex)]
      console.log(`Encontradas ${topRefs.length} refer√™ncias no topo:`, topRefs.map(r => `PREST.${r[1]} -> REF.${r[2]}`))
      
      // 2. Buscar informa√ß√µes de parcelamentos nos detalhes (podem estar em qualquer lugar)
      // Padr√£o mais flex√≠vel para capturar blocos de presta√ß√µes
      const detailPatterns = [
        // Padr√£o principal: "Presta√ß√µes Ref.¬™: XXXXX" seguido de informa√ß√µes
        /(Presta[√ßc][√µo]es\s*Ref\.?[¬∫¬™\.:]?\s*(\d{5,}))[\s\S]*?(?=Presta[√ßc][√µo]es\s*Ref|Novo\s*Banco|$)/gi,
        // Padr√£o alternativo: "Pag. a Presta√ß√µes Ref.¬™ XXXXX"
        /(Pag\.\s*a\s*Presta[√ßc][√µo]es\s*Ref\.?[¬∫¬™\.:]?\s*(\d{5,}))[\s\S]*?(?=Pag\.\s*a\s*Presta|Novo\s*Banco|$)/gi
      ]
      
      detailPatterns.forEach((pattern, patternIndex) => {
        let blockMatch: RegExpExecArray | null
        while ((blockMatch = pattern.exec(text)) !== null) {
          const ref = blockMatch[2]
          const block = blockMatch[0]
          
          console.log(`\nüìã Processando bloco ${patternIndex + 1} - REF: ${ref}`)
          console.log(`Bloco (primeiros 300 chars): ${block.substring(0, 300)}...`)
          
          const detail: InstallmentDetail = { ref }

          // Buscar correla√ß√£o com refer√™ncia do topo para obter n√∫mero da presta√ß√£o atual
          const topRef = topRefs.find(tr => tr[2] === ref)
          if (topRef) {
            const prestNumber = parseInt(topRef[1], 10)
            detail.installmentNumber = prestNumber
            console.log(`‚úÖ Correla√ß√£o encontrada: PREST.${prestNumber} -> REF.${ref}`)
          }

          // 3. Buscar informa√ß√µes espec√≠ficas no bloco
          
          // Transa√ß√£o/Merchant
          const merchantPatterns = [
            /Transa[√ßc][√£a]o:\s*([^\n\r]+)/i,
            /Comerciante:\s*([^\n\r]+)/i,
            /Estabelecimento:\s*([^\n\r]+)/i
          ]
          
          for (const pattern of merchantPatterns) {
            const match = pattern.exec(block)
            if (match) {
              detail.merchant = match[1].trim()
              console.log(`üè™ Merchant: ${detail.merchant}`)
              break
            }
          }

          // Data da Transa√ß√£o
          const txDatePatterns = [
            /Data\s*(?:da\s*)?Transa[√ßc][√£a]o:\s*(\d{2}[\.\/-]\d{2}[\.\/-]\d{4})/i,
            /Data\s*(?:da\s*)?Compra:\s*(\d{2}[\.\/-]\d{2}[\.\/-]\d{4})/i,
            /Data:\s*(\d{2}[\.\/-]\d{2}[\.\/-]\d{4})/i
          ]
          
          for (const pattern of txDatePatterns) {
            const match = pattern.exec(block)
            if (match) {
              const [d, m, y] = match[1].replace(/[\/-]/g, '.').split('.')
              detail.transactionDate = `${y}-${m}-${d}`
              console.log(`üìÖ Data transa√ß√£o: ${detail.transactionDate}`)
              break
            }
          }

          // Data do D√©bito (pode estar em tabela)
          const debitDatePatterns = [
            /Data\s*do\s*D[√©e]bito[\s\n\r]+(\d{2}[\.\/-]\d{2}[\.\/-]\d{4})/i,
            /D[√©e]bito[\s\n\r]+(\d{2}[\.\/-]\d{2}[\.\/-]\d{4})/i
          ]
          
          for (const pattern of debitDatePatterns) {
            const match = pattern.exec(block)
            if (match) {
              const [d, m, y] = match[1].replace(/[\/-]/g, '.').split('.')
              detail.debitDate = `${y}-${m}-${d}`
              console.log(`üí≥ Data d√©bito: ${detail.debitDate}`)
              break
            }
          }

          // N.¬∫ Presta√ß√£o: X/Y (MAIS IMPORTANTE - v√°rias tentativas)
          const installmentPatterns = [
            // Padr√£o em tabela
            /N\.?[¬∫o]\s*Presta[√ßc][a√£]o[\s\n\r]+(\d{1,2})\s*\/\s*(\d{1,2})/i,
            // Padr√£o inline
            /N\.?[¬∫o]\s*Presta[√ßc][a√£]o[:\s]*(\d{1,2})\s*\/\s*(\d{1,2})/i,
            // Padr√£o mais flex√≠vel
            /(\d{1,2})\s*\/\s*(\d{1,2})[\s\n\r]*(?:presta√ß√µes?|parcelas?)/i,
            // Padr√£o reverso
            /(?:presta√ß√£o|parcela)\s*(\d{1,2})\s*de\s*(\d{1,2})/i
          ]
          
          for (const pattern of installmentPatterns) {
            const match = pattern.exec(block)
            if (match) {
              let currentInst, totalInst
              
              // Para padr√£o reverso (presta√ß√£o X de Y)
              if (pattern.source.includes('de')) {
                currentInst = parseInt(match[1], 10)
                totalInst = parseInt(match[2], 10)
              } else {
                currentInst = parseInt(match[1], 10)
                totalInst = parseInt(match[2], 10)
              }
              
              // Validar se faz sentido
              if (currentInst <= totalInst && totalInst >= 2 && totalInst <= 60) {
                if (!detail.installmentNumber) {
                  detail.installmentNumber = currentInst
                }
                detail.totalInstallments = totalInst
                console.log(`üí∞ Parcelas: ${currentInst}/${totalInst}`)
                break
              }
            }
          }

          // Valor original da compra
          const valuePatterns = [
            /Valor(?:\s*original)?:\s*([\d\.,]+)/i,
            /Montante:\s*([\d\.,]+)/i,
            /Total:\s*([\d\.,]+)/i
          ]
          
          for (const pattern of valuePatterns) {
            const match = pattern.exec(block)
            if (match) {
              detail.originalAmount = parsePTNumber(match[1])
              console.log(`üíµ Valor original: ${detail.originalAmount}`)
              break
            }
          }

          // TAN (Taxa de juro)
          const tanPatterns = [
            /TAN:\s*([\d\.,]+)\s*%/i,
            /Taxa:\s*([\d\.,]+)\s*%/i,
            /Juro:\s*([\d\.,]+)\s*%/i
          ]
          
          for (const pattern of tanPatterns) {
            const match = pattern.exec(block)
            if (match) {
              detail.tan = parsePTNumber(match[1])
              console.log(`üìä TAN: ${detail.tan}%`)
              break
            }
          }

          // Se n√£o encontrou o total de parcelas no bloco, tentar deduzir dos outros
          if (!detail.totalInstallments && detail.installmentNumber) {
            // Buscar outras refer√™ncias com mesmo valor para deduzir total
            const sameValueRefs = topRefs.filter(tr => tr[2] !== ref)
            if (sameValueRefs.length > 0) {
              const maxPrest = Math.max(...sameValueRefs.map(tr => parseInt(tr[1], 10)), detail.installmentNumber)
              if (maxPrest > detail.installmentNumber) {
                detail.totalInstallments = maxPrest
                console.log(`üéØ Total deduzido: ${detail.totalInstallments} (baseado em outras refs)`)
              }
            }
          }

          map[ref] = detail
          console.log(`‚úÖ Processado REF ${ref}:`, detail)
        }
      })

      console.log(`\nüìà Resumo: ${Object.keys(map).length} parcelamentos processados`)
      return map
    }

    // Identificar tipo de documento e banco
    console.log('Identificando tipo de documento e banco...')
    
    // Verificar se √© fatura de cart√£o de cr√©dito
    const { data: isCreditCardResult } = await supabase
      .rpc('is_credit_card_statement', { text_content: extractedText })
    
    const isCreditCard = isCreditCardResult || false
    console.log(`√â fatura de cart√£o: ${isCreditCard}`)

    let detectedBank = 'Banco n√£o identificado'
    let documentType = 'bank_statement'
    
    if (isCreditCard) {
      documentType = 'credit_card_statement'
      
      // Identificar banco emissor do cart√£o
      const { data: bankIdentificationResult } = await supabase
        .rpc('identify_credit_card_bank', { text_content: extractedText })
      
      if (bankIdentificationResult && bankIdentificationResult.length > 0) {
        detectedBank = bankIdentificationResult[0].bank_name
        console.log(`Banco do cart√£o identificado: ${detectedBank} (confian√ßa: ${bankIdentificationResult[0].confidence}%)`)
      }
    } else {
      // Buscar padr√µes conhecidos para contexto de extratos banc√°rios
      const { data: knownBanks } = await supabase
        .from('bank_patterns')
        .select('bank_name, patterns')
        .limit(50)
      
      const knownBanksContext = knownBanks?.map((bank: any) => 
        `${bank.bank_name}: ${bank.patterns}`
      ).join('\n') || ''

      const bankIdentification = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© um especialista em identifica√ß√£o de bancos e institui√ß√µes financeiras. Analise o texto fornecido e identifique o banco/institui√ß√£o, mesmo que n√£o esteja na lista de bancos conhecidos. Seja preciso e retorne apenas o nome do banco.`
          },
          {
            role: 'user',
            content: `Analise este texto de extrato banc√°rio e identifique o banco/institui√ß√£o:${knownBanksContext}\n\nTEXTO DO DOCUMENTO:\n${extractedText}`
          }
        ],
        temperature: 0,
        max_tokens: 100
      })

      detectedBank = bankIdentification.choices[0]?.message?.content?.trim() || 'Banco n√£o identificado'
    }
    
    console.log(`Tipo: ${documentType}, Banco: ${detectedBank}`)

    // Buscar contas do usu√°rio para contexto
    const { data: accounts } = await supabase
      .from('accounts')
      .select('id, name, bank_name')
      .eq('user_id', user.id)

    // Buscar cart√µes de cr√©dito do usu√°rio
    const { data: creditCards } = await supabase
      .from('credit_cards')
      .select('id, card_name, bank_name, last_four_digits, card_brand')
      .eq('user_id', user.id)
      .eq('is_active', true)

    // Buscar padr√µes de transa√ß√£o conhecidos para melhorar categoriza√ß√£o
    const { data: transactionPatterns } = await supabase
      .from('transaction_patterns')
      .select('pattern_name, keywords, suggested_category, merchant_type, confidence_score')
      .eq('is_active', true)
      .order('confidence_score', { ascending: false })

    // Buscar categorias existentes do usu√°rio
    const { data: userCategories } = await supabase
      .from('categories')
      .select('name, type')
      .or(`user_id.eq.${user.id},is_default.eq.true`)

    const categoryContext = userCategories?.map(cat => `${cat.name} (${cat.type})`).join(', ') || 
      'alimentacao, transporte, saude, educacao, lazer, casa, roupas, tecnologia, servicos, transferencia, salario, compras_parceladas, outros'

    // Estrat√©gia otimizada para processar documentos grandes rapidamente
    const processLargeDocumentFast = (text: string, isCreditCard: boolean): string => {
      // Se documento √© pequeno, processar normalmente
      if (text.length <= 10000) {
        return text
      }

      console.log(`‚ö° Documento grande (${text.length} chars), usando processamento r√°pido...`)
      
      if (isCreditCard) {
        // Estrat√©gia otimizada: extrair se√ß√µes essenciais sem regex complexa
        const sections = []
        
        // 1. Header com informa√ß√µes de cart√µes (primeira parte at√© movimentos)
        const headerEnd = text.search(/Detalhe dos movimentos|Data dos movimentos/i)
        if (headerEnd > 0) {
          sections.push(text.substring(0, headerEnd + 500)) // +500 para pegar in√≠cio dos movimentos
        }
        
        // 2. Todas as transa√ß√µes dos cart√µes (parte do meio)
        const movementsStart = text.search(/Cart√£o n\.¬∫/i)
        const prestationsStart = text.search(/Pagamento a presta√ß√µes/i)
        
        if (movementsStart > 0 && prestationsStart > 0) {
          sections.push(text.substring(movementsStart, prestationsStart))
        } else if (movementsStart > 0) {
          sections.push(text.substring(movementsStart, text.length - 1000)) // Deixar espa√ßo para presta√ß√µes
        }
        
        // 3. Se√ß√£o de presta√ß√µes (final)
        if (prestationsStart > 0) {
          sections.push(text.substring(prestationsStart))
        }
        
        const result = sections.join('\n\n=== SE√á√ÉO ===\n\n')
        console.log(`‚ö° Processamento r√°pido: ${result.length} chars (${sections.length} se√ß√µes)`)
        return result
      }
      
      // Para extratos banc√°rios, manter simples
      return text.length > 12000 ? 
        `${text.substring(0, 8000)}\n\n[... OMITIDO ...]\n\n${text.substring(text.length - 4000)}` 
        : text
    }

    // Processar documento com estrat√©gia otimizada
    const processedText = processLargeDocumentFast(extractedText, isCreditCard)

    const patternsContext = transactionPatterns?.slice(0, 50)
      .map(p => `${p.pattern_name}: ${p.keywords.join(', ')} ‚Üí ${p.suggested_category}`)
      .join('\n') || ''

    // Extrair transa√ß√µes usando IA com contexto melhorado
    let extractionResult
    
    if (isCreditCard) {
      // Processo espec√≠fico para faturas de cart√£o de cr√©dito
      const creditCardExtraction = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© um especialista em an√°lise de faturas de cart√£o de cr√©dito portugueses e brasileiros. Sua fun√ß√£o √© extrair informa√ß√µes da fatura e transa√ß√µes com categoriza√ß√£o precisa.

INSTRU√á√ïES IMPORTANTES:
1. Retorne APENAS um objeto JSON v√°lido
2. Use as categorias dispon√≠veis do usu√°rio: ${categoryContext}
3. Para categoriza√ß√£o, considere os padr√µes conhecidos abaixo
4. Amounts: sempre valores positivos para compras
5. Dates: formato YYYY-MM-DD
6. Identifique informa√ß√µes da fatura (vencimento, valor total, limite, etc.)
7. EXTRAIA TODAS AS TRANSA√á√ïES - n√£o omita nenhuma linha de compra
8. Para parcelamentos (PREST.), extraia apenas o valor da presta√ß√£o mensal, n√£o o valor total
9. Se uma transa√ß√£o tem REF.¬™, inclua essa refer√™ncia na descri√ß√£o

TEXTO COMPLETO DO DOCUMENTO (${extractedText.length} caracteres originais, ${processedText.length} processados):
${processedText}

PADR√ïES CONHECIDOS DE COMERCIANTES:
${patternsContext}

Formato JSON esperado:
{
  "document_type": "credit_card_statement",
  "card_info": {
    "bank": "nome do banco emissor",
    "last_four_digits": "√∫ltimos 4 d√≠gitos",
    "card_brand": "visa/mastercard/elo/etc",
    "credit_limit": number,
    "statement_date": "YYYY-MM-DD",
    "due_date": "YYYY-MM-DD",
    "previous_balance": number,
    "payments": number,
    "new_purchases": number,
    "interest_charges": number,
    "fees": number,
    "total_amount": number,
    "minimum_payment": number
  },
  "transactions": [
    {
      "date": "YYYY-MM-DD",
      "merchant": "Nome do comerciante",
      "description": "Descri√ß√£o da transa√ß√£o",
      "amount": number,
      "category": "categoria_identificada",
      "installments": number,
      "installment_info": "1/12" ou null
    }
  ]
}`
          },
          {
            role: 'user',
            content: `Analise esta fatura de cart√£o de cr√©dito e extraia todas as informa√ß√µes e transa√ß√µes:\n\n${processedText}`
          }
        ],
        temperature: 0.1,
        max_tokens: 6144,
        response_format: { type: "json_object" },
      })

      extractionResult = creditCardExtraction.choices[0]?.message?.content?.trim()
    } else {
      // Processo original para extratos banc√°rios
      const transactionExtraction = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© um especialista em an√°lise de extratos banc√°rios portugueses e europeus. Sua fun√ß√£o √© extrair transa√ß√µes e categoriz√°-las com precis√£o usando o contexto fornecido.

INSTRU√á√ïES IMPORTANTES:
1. Retorne APENAS um objeto JSON v√°lido
2. Use as categorias dispon√≠veis do usu√°rio: ${categoryContext}
3. Para categoriza√ß√£o, considere os padr√µes conhecidos abaixo
4. Se n√£o conseguir identificar uma categoria espec√≠fica, use "outros"
5. Amounts: negativos para d√©bitos/gastos, positivos para cr√©ditos/receitas
6. Dates: formato YYYY-MM-DD

PADR√ïES CONHECIDOS DE COMERCIANTES:
${patternsContext}

Formato JSON esperado:
{
  "document_type": "bank_statement",
  "transactions": [
    {
      "date": "YYYY-MM-DD",
      "description": "Descri√ß√£o exata da transa√ß√£o",
      "amount": number,
      "type": "credit" | "debit", 
      "category": "categoria_identificada"
    }
  ],
  "account_info": {
    "bank": "nome do banco",
    "account_number": "n√∫mero parcial se dispon√≠vel",
    "period": "per√≠odo do extrato"
  }
}`
          },
          {
            role: 'user',
            content: `Analise este extrato banc√°rio portugu√™s e extraia as transa√ß√µes com categoriza√ß√£o precisa:\n\n${processedText}`
          }
        ],
        temperature: 0.1,
        max_tokens: 6144,
        response_format: { type: "json_object" },
      })

      extractionResult = transactionExtraction.choices[0]?.message?.content?.trim()
    }
    
    if (!extractionResult) {
      throw new Error('N√£o foi poss√≠vel extrair transa√ß√µes do PDF')
    }

    // Limpar a resposta para garantir que √© um JSON v√°lido
    const jsonMatch = extractionResult.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      extractionResult = jsonMatch[0]
    }

  // Parse do resultado JSON
    let parsedResult
    try {
      parsedResult = JSON.parse(extractionResult)
    } catch (e) {
      console.error("Erro de parsing do JSON:", e)
      console.error("String que falhou o parsing:", extractionResult)
      throw new Error('Erro ao processar dados extra√≠dos. A resposta da IA n√£o √© um JSON v√°lido.')
    }

    // P√≥s-processamento: enriquecer presta√ß√µes PT e melhorar categoriza√ß√£o
    // 1) Extrair informa√ß√µes de cart√µes (incluindo dependentes)
    const creditCardsInfo = await extractCreditCardsInfo(extractedText)
    
    // 2) Correlacionar refer√™ncias de presta√ß√µes encontradas no final do documento
    const installmentDetailsMap = extractInstallmentDetails(extractedText)

    if (parsedResult.transactions && transactionPatterns) {
      parsedResult.transactions = parsedResult.transactions.map((transaction: any) => {
        const description = transaction.description?.toLowerCase() || ''
        // Tentar capturar REF da descri√ß√£o ex.: "REF.¬™ 00122905" ou "REF: 00122905"
        const refMatch = /ref[¬∫¬™\.]?\s*[:\.]?\s*(\d{5,})/i.exec(transaction.description || '')
        if (refMatch) {
          const ref = refMatch[1]
          const detail = installmentDetailsMap[ref]
          if (detail) {
            if (!transaction.installments && detail.totalInstallments) {
              transaction.installments = detail.totalInstallments
            }
            if (!transaction.installment_info && detail.installmentNumber && detail.totalInstallments) {
              transaction.installment_info = `${detail.installmentNumber}/${detail.totalInstallments}`
            }
            // Adicionar installment_number separado para o banco
            if (detail.installmentNumber) {
              transaction.installment_number = detail.installmentNumber
            }
            if (!transaction.merchant && detail.merchant) {
              transaction.merchant = detail.merchant
            }
            // Se n√£o houver date, usar debitDate ou transactionDate do detalhe
            if (!transaction.date && (detail.debitDate || detail.transactionDate)) {
              transaction.date = detail.debitDate || detail.transactionDate
            }
            // Adicionar informa√ß√µes adicionais do parcelamento
            if (detail.tan) {
              transaction.tan_rate = detail.tan
            }
            if (detail.originalAmount) {
              transaction.original_amount = detail.originalAmount
            }
            // Sugerir categoria se for presta√ß√£o
            if (!transaction.category && /prest\.|pag\.\s*a\s*prest/i.test(description)) {
              transaction.category = 'compras_parceladas'
            }
          }
        }
        
        // Buscar padr√£o que corresponda √† descri√ß√£o
        const matchingPattern = transactionPatterns.find((pattern: any) => 
          pattern.keywords.some((keyword: string) => 
            description.includes(keyword.toLowerCase())
          )
        )
        
        if (matchingPattern && matchingPattern.confidence_score >= 85) {
          console.log(`Padr√£o encontrado: ${description} ‚Üí ${matchingPattern.suggested_category} (confian√ßa: ${matchingPattern.confidence_score}%)`)
          return {
            ...transaction,
            category: matchingPattern.suggested_category,
            pattern_matched: matchingPattern.pattern_name,
            confidence: matchingPattern.confidence_score
          }
        }
        
        return transaction
      })
    }

    // Auto-cria√ß√£o de conta/cart√£o se n√£o existir
    let autoCreatedAccount = null
    let autoCreatedCards = []
    
    try {
      // Se √© fatura de cart√£o e temos m√∫ltiplos cart√µes detectados, criar todos
      if (documentType === 'credit_card_statement' && creditCardsInfo.length > 0) {
        console.log(`Processando ${creditCardsInfo.length} cart√µes detectados...`)
        
        for (const cardInfo of creditCardsInfo) {
          // Extrair √∫ltimos 4 d√≠gitos do n√∫mero do cart√£o
          const lastFourDigits = cardInfo.cardNumber.slice(-4)
          
          const { data: cardData, error: cardError } = await supabase
            .rpc('auto_create_credit_card_with_holder', {
              p_user_id: user.id,
              p_bank_name: cardInfo.bank,
              p_card_holder: cardInfo.cardHolder,
              p_last_four_digits: lastFourDigits,
              p_card_brand: parsedResult.card_info?.card_brand || null,
              p_credit_limit: cardInfo.sharedLimit || parsedResult.card_info?.credit_limit || null,
              p_is_dependent: cardInfo.isDependent || false
            })

          if (cardError) {
            console.error(`Erro ao criar/encontrar cart√£o ${cardInfo.cardNumber}:`, cardError)
          } else if (cardData) {
            autoCreatedCards.push({
              ...cardData,
              cardHolder: cardInfo.cardHolder,
              cardNumber: cardInfo.cardNumber,
              isDependent: cardInfo.isDependent
            })
            console.log(`${cardData.was_created ? 'Criado' : 'Encontrado'} cart√£o: ${cardInfo.cardHolder} - ${cardInfo.cardNumber}`)
          }
        }
        
        // Usar o primeiro cart√£o como conta principal para compatibilidade
        if (autoCreatedCards.length > 0) {
          autoCreatedAccount = {
            account_id: autoCreatedCards[0].card_id,
            account_type: 'credit_card',
            was_created: autoCreatedCards[0].was_created,
            account_name: autoCreatedCards[0].card_name
          }
        }
      } else {
        // Processamento original para outros tipos de documento
        const accountParams = {
          p_user_id: user.id,
          p_document_type: documentType,
          p_bank_name: detectedBank,
          p_last_four_digits: parsedResult.card_info?.last_four_digits || null,
          p_card_brand: parsedResult.card_info?.card_brand || null,
          p_account_number: parsedResult.account_info?.account_number || null,
          p_credit_limit: parsedResult.card_info?.credit_limit || null,
          p_currency: 'EUR' // Pode ser detectado no futuro
        }

        const { data: autoAccountData, error: autoAccountError } = await supabase
          .rpc('auto_process_and_create_account', accountParams)

        if (autoAccountError) {
          console.error('Erro na auto-cria√ß√£o de conta:', autoAccountError)
        } else if (autoAccountData && autoAccountData.length > 0) {
          autoCreatedAccount = autoAccountData[0]
          console.log(`${autoCreatedAccount.was_created ? 'Criada' : 'Encontrada'} ${autoCreatedAccount.account_type}: ${autoCreatedAccount.account_name}`)
        }
      }
    } catch (autoError) {
      console.error('Erro na auto-cria√ß√£o:', autoError)
    }

    return NextResponse.json({
      success: true,
      document_type: documentType,
      is_credit_card: isCreditCard,
      detected_bank: detectedBank,
      extracted_text_length: extractedText.length,
      transactions: parsedResult.transactions || [],
      account_info: parsedResult.account_info || {},
      card_info: parsedResult.card_info || null,
      credit_cards_info: creditCardsInfo, // Informa√ß√µes de cart√µes dependentes
      installment_details: installmentDetailsMap, // Detalhes dos parcelamentos
      user_accounts: accounts || [],
      user_credit_cards: creditCards || [],
      auto_created_account: autoCreatedAccount,
      auto_created_cards: autoCreatedCards, // Todos os cart√µes criados/encontrados
      processing_method: extractedText.length > 1000 ? 'google_ocr' : 'pdf_parse',
      suggested_action: isCreditCard ? 'create_or_update_credit_card' : 'import_to_account'
    })

  } catch (error: any) {
    console.error('Erro ao processar PDF:', error)
    
    // Mensagens espec√≠ficas baseadas no tipo de erro
    if (error.message?.includes('Google Cloud n√£o configurado')) {
      return NextResponse.json({ 
        error: 'Este PDF √© escaneado e requer OCR. Configure as credenciais do Google Cloud para processamento avan√ßado.',
        suggestion: 'Tente usar um extrato digital (PDF com texto selecion√°vel) do seu banco online.'
      }, { status: 400 })
    }
    
    if (error.message?.includes('limite di√°rio')) {
      return NextResponse.json({ 
        error: 'Limite di√°rio de processamento atingido.',
        suggestion: 'Tente novamente amanh√£ ou use PDFs com texto selecion√°vel que s√£o processados gratuitamente.'
      }, { status: 429 })
    }
    
    return NextResponse.json({ 
      error: error.message || 'Erro interno do servidor',
      suggestion: 'Verifique se o PDF √© um extrato banc√°rio v√°lido e tente novamente.'
    }, { status: 500 })
  }
}
